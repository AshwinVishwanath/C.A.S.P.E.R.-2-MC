/**
 * Build-time syndrome table generator for CRC-32 single-bit correction.
 *
 * Usage:
 *   npx ts-node scripts/generate_syndrome_table.ts
 *
 * Generates syndrome tables for the three flight-computer packet types:
 *   - FC_MSG_FAST:  15 payload bytes (120 entries)
 *   - FC_MSG_GPS:    8 payload bytes  (64 entries)
 *   - FC_MSG_EVENT:  5 payload bytes  (40 entries)
 *
 * Output: prints TypeScript Map initializers to stdout, suitable for
 * copy-pasting into a source file as compile-time constants.
 *
 * The CRC-32 uses standard CRC-32/ISO-HDLC:
 *   - Polynomial: 0x04C11DB7 (reflected: 0xEDB88320)
 *   - Initial value: 0xFFFFFFFF
 *   - Final XOR: 0xFFFFFFFF
 *   - Reflect input/output: YES
 *   - Byte-by-byte processing
 */

const POLY = 0xEDB88320;

/**
 * Precomputed 256-entry lookup table for reflected CRC-32.
 */
const CRC32_TABLE: Uint32Array = (() => {
  const table = new Uint32Array(256);
  for (let i = 0; i < 256; i++) {
    let crc = i;
    for (let bit = 0; bit < 8; bit++) {
      if (crc & 1) {
        crc = (crc >>> 1) ^ POLY;
      } else {
        crc = crc >>> 1;
      }
    }
    table[i] = crc >>> 0;
  }
  return table;
})();

/**
 * Raw CRC-32 with zero init for syndrome computation.
 *
 * Syndrome tables require init=0 and NO final XOR because the syndrome
 * of a single-bit error is:
 *   syndrome = CRC(x^e) XOR CRC(x)
 *            = [raw(x^e, init) ^ F] XOR [raw(x, init) ^ F]
 *            = raw(x^e, init) XOR raw(x, init)
 *            = raw(e, 0)
 *
 * where F = 0xFFFFFFFF (final XOR, which cancels out).
 */
function crc32_zero_init(data: Uint8Array): number {
  let crc = 0x00000000;

  for (let i = 0; i < data.length; i++) {
    crc = CRC32_TABLE[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
  }

  return crc >>> 0;
}

function generate_table(payload_length: number): Map<number, number> {
  const table = new Map<number, number>();

  for (let bit_pos = 0; bit_pos < payload_length * 8; bit_pos++) {
    const test_payload = new Uint8Array(payload_length);
    const byte_idx = Math.floor(bit_pos / 8);
    const bit_in_byte = 7 - (bit_pos % 8);
    test_payload[byte_idx] = 1 << bit_in_byte;

    const syndrome = crc32_zero_init(test_payload);
    table.set(syndrome, bit_pos);
  }

  return table;
}

function format_table(name: string, payload_length: number): string {
  const table = generate_table(payload_length);
  const entries: string[] = [];

  // Sort by bit position for deterministic, readable output.
  const sorted = [...table.entries()].sort((a, b) => a[1] - b[1]);

  for (const [syndrome, bit_pos] of sorted) {
    entries.push(`  [0x${syndrome.toString(16).toUpperCase().padStart(8, '0')}, ${bit_pos}]`);
  }

  return [
    `/** Syndrome table for ${name} (${payload_length} payload bytes, ${payload_length * 8} entries). */`,
    `export const ${name}_SYNDROME_TABLE: Map<number, number> = new Map([`,
    entries.join(',\n'),
    `]);`,
  ].join('\n');
}

// --- Main ---

const PACKET_TYPES: Array<[string, number]> = [
  ['FC_MSG_FAST', 15],
  ['FC_MSG_GPS', 8],
  ['FC_MSG_EVENT', 5],
];

console.log('// Auto-generated by scripts/generate_syndrome_table.ts');
console.log('// CRC-32: standard CRC-32/ISO-HDLC (reflected polynomial 0xEDB88320)');
console.log('// Syndrome init 0x00000000 (zero-init for linearity), no final XOR');
console.log('');

for (const [name, length] of PACKET_TYPES) {
  console.log(format_table(name, length));
  console.log('');
}
