/**
 * Build-time syndrome table generator for CRC-32 single-bit correction.
 *
 * Usage:
 *   npx ts-node scripts/generate_syndrome_table.ts
 *
 * Generates syndrome tables for the three flight-computer packet types:
 *   - FC_MSG_FAST:  15 payload bytes (120 entries)
 *   - FC_MSG_GPS:    8 payload bytes  (64 entries)
 *   - FC_MSG_EVENT:  5 payload bytes  (40 entries)
 *
 * Output: prints TypeScript Map initializers to stdout, suitable for
 * copy-pasting into a source file as compile-time constants.
 *
 * The CRC-32 matches the STM32 hardware CRC peripheral:
 *   - Polynomial: 0x04C11DB7
 *   - Initial value: 0xFFFFFFFF
 *   - No final XOR, not reflected
 *   - Big-endian 32-bit word processing (zero-padded last word)
 */

const POLY = 0x04C11DB7;

/**
 * CRC-32 with zero init for syndrome computation.
 *
 * Syndrome tables require init=0 because the syndrome of a single-bit
 * error (CRC_init(x ^ e) XOR CRC_init(x)) equals CRC_0(e) due to the
 * linearity of the XOR-based CRC when the init value cancels out.
 */
function crc32_zero_init(data: Uint8Array): number {
  let crc = 0x00000000;

  const padded_len = Math.ceil(data.length / 4) * 4;
  const padded = new Uint8Array(padded_len);
  padded.set(data);

  for (let i = 0; i < padded_len; i += 4) {
    const word =
      ((padded[i] << 24) | (padded[i + 1] << 16) | (padded[i + 2] << 8) | padded[i + 3]) >>> 0;
    crc ^= word;
    for (let bit = 0; bit < 32; bit++) {
      if (crc & 0x80000000) {
        crc = ((crc << 1) ^ POLY) >>> 0;
      } else {
        crc = (crc << 1) >>> 0;
      }
    }
  }

  return crc >>> 0;
}

function generate_table(payload_length: number): Map<number, number> {
  const table = new Map<number, number>();

  for (let bit_pos = 0; bit_pos < payload_length * 8; bit_pos++) {
    const test_payload = new Uint8Array(payload_length);
    const byte_idx = Math.floor(bit_pos / 8);
    const bit_in_byte = 7 - (bit_pos % 8);
    test_payload[byte_idx] = 1 << bit_in_byte;

    const syndrome = crc32_zero_init(test_payload);
    table.set(syndrome, bit_pos);
  }

  return table;
}

function format_table(name: string, payload_length: number): string {
  const table = generate_table(payload_length);
  const entries: string[] = [];

  // Sort by bit position for deterministic, readable output.
  const sorted = [...table.entries()].sort((a, b) => a[1] - b[1]);

  for (const [syndrome, bit_pos] of sorted) {
    entries.push(`  [0x${syndrome.toString(16).toUpperCase().padStart(8, '0')}, ${bit_pos}]`);
  }

  return [
    `/** Syndrome table for ${name} (${payload_length} payload bytes, ${payload_length * 8} entries). */`,
    `export const ${name}_SYNDROME_TABLE: Map<number, number> = new Map([`,
    entries.join(',\n'),
    `]);`,
  ].join('\n');
}

// --- Main ---

const PACKET_TYPES: Array<[string, number]> = [
  ['FC_MSG_FAST', 15],
  ['FC_MSG_GPS', 8],
  ['FC_MSG_EVENT', 5],
];

console.log('// Auto-generated by scripts/generate_syndrome_table.ts');
console.log('// CRC-32: polynomial 0x04C11DB7, syndrome init 0x00000000 (zero-init for linearity)');
console.log('// STM32 hardware CRC compatible (big-endian 32-bit word processing)');
console.log('');

for (const [name, length] of PACKET_TYPES) {
  console.log(format_table(name, length));
  console.log('');
}
